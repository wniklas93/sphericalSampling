import numpy as np
import scipy as sp
import matplotlib.pyplot as plt

from mayavi import mlab
from scipy import signal
################################################################################
def euclid_2_sphere(p):
    '''
    This function transforms the euclidean representation of a point in R^3 to
    the spherical representation. This function accepts single points and
    multiple points. The format of the input must be as follows:
    p = [x,y,z]

    Parameters:
    ___________
    p:                      Points of R^3 in euclidean representation

    return:
    _______
    p_sphere:              Points of R^3 in spherical representation
    '''

    p = np.atleast_2d(p)

    x = p[:,0]
    y = p[:,1]
    z = p[:,2]

    #Transform: [x,y,z] --> [r,phi,theta]
    p_sphere = np.column_stack((np.sqrt(x**2 + y**2 + z**2),             #r
                                np.arctan2(y,x),                          #phi
                                np.arctan2(np.sqrt(x**2 + y**2),z)))      #theta

    return p_sphere

def sphere_2_euclid(p):
    '''
    This function transforms the spherical representation of a point in R^3 to
    the euclidean representation. This function accecpts single points and
    multiple points. The format of the input must be as follows:

    p = [r,phi,theta],
    where r in (-inf, inf), phi in [0,2*pi], theta in [0,pi]

    Parameters:
    ___________
    p:                          Points of R^3 in spherical representation

    return:
    _______
    p_euclidean:                Points of R^3 in euclidean representation
    '''


    p = np.atleast_2d(p)

    r =         p[:,0]
    phi =       p[:,1]
    theta =     p[:,2]

    #Transform: [r,phi,theta] --> [x,y,z]
    p_euclid_3d = np.column_stack((r*np.cos(phi)*np.sin(theta),
                                  r*np.sin(phi)*np.sin(theta),
                                  r*np.cos(theta)))

    return p_euclid_3d


def polar_2_euclid(p):
    '''
    This function transforms points in polar coordinates representation to
    points in euclidean coordinates representation

    Parameters:
    ___________
    p:                  Points of R^2 in polar representation

    return:
    _______
    p_euclid_d:         Points of R^2 in euclidean representation
    '''
    p = np.atleast_2d(p)

    r = p[:,0]
    phi = p[:,1]

    x = r * np.cos(phi)
    y = r * np.sin(phi)

    p_euclid_2d = np.column_stack((x,y))
    return p_euclid_2d

def plot_3D(p, title):
    '''
    This functions plots the given points in the 3D space. The given
    points are elements of R^3.

    Parameters:
    ___________
    p:                              To be plotted points
    title:                          Title of plot


    return:
    _______
    -

    '''
    #Set colours and render
    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111, projection='3d')

    ax.scatter(p[:,0], p[:,1], p[:,2], color='b', s=20)

    ax.set_xlim([-1,1])
    ax.set_ylim([-1,1])
    ax.set_zlim([-1,1])
    ax.set_xlabel("x-Axis")
    ax.set_ylabel("y-Axis")
    ax.set_zlabel("z-Axis")
    ax.title.set_text(title)
    plt.tight_layout()
    plt.show()

def fibonacci_sequence(N):
    '''
    This function returns the Fibonacci sequence up to the Nth
    number. Fibonacci are generated by a recursive Filter.

    Parameters:
    ___________
    N:                          Number of points
    return:
    _______
    F:                          Fibonacci sequence
    '''

    #Design filter for generating fibonacci sequence
    b = [0,1]
    a = [1,-1,-1]

    #Fibonacci number
    x = signal.unit_impulse(N)
    F = signal.lfilter(b,a,x)

    return F

def plot_2D(p, title):
    '''
    This functions plots the given points in the 2D space. The given
    points are elements of R^2.

    Parameters:
    ___________
    p:                              To be plotted points
    title:                          Title of plot


    return:
    _______
    -

    '''
    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111)

    ax.scatter(p[:,0], p[:,1], color='b', s=20)

    ax.set_xlabel("x-Axis")
    ax.set_ylabel("y-Axis")
    ax.title.set_text(title)
    plt.tight_layout()
    plt.show()

def SurfacePlot(samplePoints, data, title):
    """Plots 3D surface plot over given theta/phi range by calculating cartesian coordinate equivalent of spherical form.
    __________
    Variables:
    samplePoints:       Array of sample points described by spherical coordinates (Note: The radius must not be passed, thus
                        the shape must be (M,2), where M describes the numer of sample points)
    data:               1d array storing the transfer function for one specific frequency. Data must be organized according to
                        the data format of sofa convecntion
    title:              Title of plot


    """

    print("Processing SurfacePlot...")

    phi = samplePoints[:,0]
    theta = samplePoints[:,1]

    X = data*np.sin(theta)*np.cos(phi)
    Y = data*np.sin(theta)*np.sin(phi)
    Z = data*np.cos(theta)

    # use scipy for delaunay:
    p2d = np.vstack([phi,theta]).T
    d2d = sp.spatial.Delaunay(p2d)

    fig = mlab.figure(figure = title, bgcolor=(1, 0.7, 1), fgcolor=(0.5, 0.5, 0.5))

    # Generate triangular Mesh:
    tmesh = mlab.triangular_mesh(X, Y, Z, d2d.vertices,
                                 colormap='jet')

    # Simple plot.
    mlab.outline(extent=(0,1,0,1,0,1))
    mlab.axes(extent=(0,1,0,1,0,1))
    mlab.show()

def tpf(x,l):
    '''
    Evaluated truncated power function (tpf) at given positions.

    Parameters:
    ___________
    x:                      To be evaluated positions
    l:                      To be used exponent

    return:
    _______
    y:                      Evaluations of tpf at given positions
    '''

    x[x<0] = 0

    return x**l



#%%
